from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from pdf_utils import generate_consulting_pdf
from fastapi.responses import FileResponse
import requests
import uuid
import json
import os

app = FastAPI()

app.add_middleware(CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

ONDEMAND_API_KEY = "S6ab5e0N7RqeVEf80x1QtI1lHYfj2vJO"
agent1_id = "69680f0827b1bb913e89392b"
agent2_id = "6968108f27b1bb913e893974"
agent3_id = "6968109b27b1bb913e893978"
agent4_id = "696810a48e6b21cb8aea103c"
agent5_id = "696810aa8e6b21cb8aea1040"
agent6_id = "696810af27b1bb913e89397c"


SESSION_FILE = "session_store.json"

def load_session():
    if os.path.exists(SESSION_FILE):
        with open(SESSION_FILE, "r") as f:
            return json.load(f)
    return {}

def save_session(session):
    with open(SESSION_FILE, "w") as f:
        json.dump(session, f, indent=2)

SESSION = load_session()

CHAT_SESSION_FILE = "chat_sessions.json"

def load_chat_sessions():
    if not os.path.exists(CHAT_SESSION_FILE):
        return {}
    with open(CHAT_SESSION_FILE, "r") as f:
        return json.load(f)

def save_chat_sessions(data):
    with open(CHAT_SESSION_FILE, "w") as f:
        json.dump(data, f)

CHAT_SESSIONS = load_chat_sessions()

REPORTS = {}

def build_report_content(request_id: str) -> str:
    sections = []

    sections.append("ATLAS CONSULTING REPORT\n")
    sections.append("=" * 40)

    if "agent1" in SESSION:
        sections.append("\nPROBLEM DEFINITION\n")
        sections.append(str(SESSION["agent1"]))

    if "agent2" in SESSION:
        sections.append("\nBENCHMARKING ANALYSIS\n")
        sections.append(str(SESSION["agent2"]))

    if "agent3" in SESSION:
        sections.append("\nSTRATEGIC SCENARIOS\n")
        sections.append(str(SESSION["agent3"]))

    if "agent4" in SESSION:
        sections.append("\nEXECUTION PLAN\n")
        sections.append(str(SESSION["agent4"]))

    if "agent5" in SESSION:
        sections.append("\nRISKS & MITIGATION\n")
        sections.append(str(SESSION["agent5"]))

    if "agent6" in SESSION:
        sections.append("\nDECISION & KPIs\n")
        sections.append(str(SESSION["agent6"]))

    sections.append("\nGenerated by ATLAS – AI-native Consulting")

    return "\n".join(sections)



REQUESTS = {
    "demo-1": {
        "question": "I run a small packaged food manufacturing unit supplying snacks to local distributors. Over the last 12 months, sales volumes have grown by around 18%, but profit margins have fallen from about 9% to 4%. Raw material costs such as edible oil and packaging have increased significantly, and logistics expenses have also risen. My operating expenses are mostly fixed, and distributors resist price increases. I need to decide whether to focus on cost reduction, selective price increases, or continue operations as-is.",
        "business_type": "retail",
        "location": "India",
    }
}

def build_atlas_context(request_id: str) -> str:
    parts = []

    if "agent1" in SESSION:
        parts.append(f"PROBLEM DEFINITION:\n{SESSION['agent1']}")

    if "agent2" in SESSION:
        parts.append(f"\nBENCHMARKING:\n{SESSION['agent2']}")

    if "agent3" in SESSION:
        parts.append(f"\nSTRATEGIC SCENARIOS:\n{SESSION['agent3']}")

    if "agent4" in SESSION:
        parts.append(f"\nACTION PLAN:\n{SESSION['agent4']}")

    if "agent5" in SESSION:
        parts.append(f"\nRISKS:\n{SESSION['agent5']}")

    if "agent6" in SESSION:
        parts.append(f"\nKPIS & DECISION:\n{SESSION['agent6']}")

    parts.append("""
RULES:
- Use ONLY the above context
- Do not invent data
- If something is missing, say so clearly
""")

    return "\n".join(parts)


@app.get("/consulting-input/{request_id}")
def get_consulting_input(request_id: str):
    if request_id not in REQUESTS:
        return {"error": "Request not found"}

    return REQUESTS[request_id]

''' Agent 1 Problem Structuring Endpoints '''

#Apply in Frontend

# @app.post("/atlas/input")
# def create_input(payload: dict):
#     request_id = str(uuid.uuid4())

#     REQUESTS[request_id] = {
#         "question": payload.get("question"),
#         "business_type": payload.get("business_type"),
#         "location": payload.get("location")
#     }

#     return {"request_id": request_id}

def normalize_agent_payload(payload):

    if isinstance(payload, dict):
        return payload

    if isinstance(payload, str):
        raw = payload.strip()
        start = raw.find("{")
        end = raw.rfind("}")

        if start != -1 and end != -1:
            try:
                return json.loads(raw[start:end + 1])
            except Exception as e:
                return {
                    "error": "JSON parse failed",
                    "exception": str(e),
                    "raw": raw
                }

    return {
        "error": "Invalid payload format",
        "raw": payload
    }

@app.post("/atlas/agent1/run")
def run_agent1():
    url = f"https://api.on-demand.io/automation/api/workflow/{agent1_id}/execute"
    headers = {"apikey": ONDEMAND_API_KEY}
    # body = {"request_id": request_id}

    r = requests.post(url, headers=headers)
    r.raise_for_status()

    return {"status": "triggered"}  #return {"status": "triggered", "request_id": request_id}

@app.post("/ondemand/agent1")
async def receive_agent1(request: Request):
    payload = await request.json()
    print("Agent 1 webhook received")
    SESSION["agent1"] = normalize_agent_payload(payload)
    save_session(SESSION)
    return {"status": "ok"}

@app.get("/atlas/agent1")
def get_agent1():
    return SESSION.get("agent1", {})

@app.get("/agent1-output")
def agent1_output():
    return SESSION.get("agent1", {})

''' Agent 2 Benchmark Endpoints '''

@app.post("/atlas/agent2/run")
def run_agent2():
    url = f"https://api.on-demand.io/automation/api/workflow/{agent2_id}/execute"
    headers = {"apikey": ONDEMAND_API_KEY}

    r = requests.post(url, headers=headers)
    r.raise_for_status()

    return {"status": "triggered"}

@app.post("/ondemand/agent2")
async def receive_agent2(request: Request):
    payload = await request.json()
    print("Agent 2 webhook received")
    SESSION["agent2"] = normalize_agent_payload(payload)
    save_session(SESSION)
    return {"status": "ok"}


@app.get("/atlas/agent2")
def get_agent2():
    return SESSION.get("agent2", {})

@app.get("/agent2-output")
def agent2_output():
    return SESSION.get("agent2", {})

'''Agent 3 Recommendation Simulation Endpoints '''

@app.post("/atlas/agent3/run")
def run_agent3():
    url = f"https://api.on-demand.io/automation/api/workflow/{agent3_id}/execute"
    headers = {"apikey": ONDEMAND_API_KEY}

    r = requests.post(url, headers=headers)
    r.raise_for_status()

    return {"status": "triggered"}


@app.post("/ondemand/agent3")
async def receive_agent3(request: Request):
    payload = await request.json()
    print("Agent 3 webhook received")
    SESSION["agent3"] = normalize_agent_payload(payload)
    save_session(SESSION)
    return {"status": "ok"}


@app.get("/atlas/agent3")
def get_agent3():
    return SESSION.get("agent3", {})

@app.get("/agent3-output")
def agent3_output():
    return SESSION.get("agent3", {})

''' Agent 4 Action Plan '''

@app.post("/atlas/agent4/run")
def run_agent4():
    url = f"https://api.on-demand.io/automation/api/workflow/{agent4_id}/execute"
    headers = {"apikey": ONDEMAND_API_KEY}

    r = requests.post(url, headers=headers)
    r.raise_for_status()

    return {"status": "triggered"}

@app.post("/ondemand/agent4")
async def receive_agent4(request: Request):
    payload = await request.json()
    print("Agent 4 webhook received")
    SESSION["agent4"] = normalize_agent_payload(payload)
    save_session(SESSION)
    return {"status": "ok"}


@app.get("/atlas/agent4")
def get_agent4():
    return SESSION.get("agent4", {})

@app.get("/agent4-output")
def agent4_output():
    return SESSION.get("agent4", {})

''' Agent 5 Risk Assessment '''

@app.post("/atlas/agent5/run")
def run_agent5():
    url = f"https://api.on-demand.io/automation/api/workflow/{agent5_id}/execute"
    headers = {"apikey": ONDEMAND_API_KEY}

    r = requests.post(url, headers=headers)
    r.raise_for_status()

    return {"status": "triggered"}

@app.post("/ondemand/agent5")
async def receive_agent5(request: Request):
    payload = await request.json()
    print("Agent 5 webhook received")
    SESSION["agent5"] = normalize_agent_payload(payload)
    save_session(SESSION)
    return {"status": "ok"}

@app.get("/atlas/agent5")
def get_agent5():
    return SESSION.get("agent5", {})

@app.get("/agent5-output")
def agent5_output():
    return SESSION.get("agent5", {})

''' Agent 6 KPI & Metrics '''

@app.post("/atlas/agent6/run")
def run_agent6():
    url = f"https://api.on-demand.io/automation/api/workflow/{agent6_id}/execute"
    headers = {"apikey": ONDEMAND_API_KEY}

    r = requests.post(url, headers=headers)
    r.raise_for_status()

    return {"status": "triggered"}

@app.post("/ondemand/agent6")
async def receive_agent6(request: Request):
    payload = await request.json()
    print("Agent 6 webhook received")
    SESSION["agent6"] = normalize_agent_payload(payload)
    save_session(SESSION)
    return {"status": "ok"}

@app.get("/atlas/agent6")
def get_agent6():
    return SESSION.get("agent6", {})

@app.get("/agent6-output")
def agent6_output():
    return SESSION.get("agent6", {})

# ''' Atlas Chat Session Management '''

@app.post("/atlas/chat/start/{request_id}")
def start_chat(request_id: str):
    if request_id not in REQUESTS:
        return {"error": "Invalid request_id"}

    if request_id in CHAT_SESSIONS:
        return {
            "chat_session_id": CHAT_SESSIONS[request_id],
            "status": "already_started"
        }

    url = "https://api.on-demand.io/chat/v1/sessions"
    headers = {
        "apikey": ONDEMAND_API_KEY,
        "Content-Type": "application/json"
    }

    payload = {
        "externalUserId": request_id,
        "pluginIds": []
    }

    r = requests.post(url, json=payload, headers=headers)
    r.raise_for_status()

    session_id = r.json()["data"]["id"]
    CHAT_SESSIONS[request_id] = session_id
    save_chat_sessions(CHAT_SESSIONS)
    return {
        "chat_session_id": session_id,
        "status": "started"
    }

@app.post("/atlas/chat/query/{request_id}")
async def chat_query(request_id: str, request: Request):
    if request_id not in CHAT_SESSIONS:
        return {"error": "Chat not started for this request_id"}

    body = await request.json()
    user_query = body.get("query")

    if not user_query:
        return {"error": "query field required"}

    session_id = CHAT_SESSIONS[request_id]
    context = build_atlas_context(request_id)

    url = f"https://api.on-demand.io/chat/v1/sessions/{session_id}/query"
    headers = {
        "apikey": ONDEMAND_API_KEY,
        "Content-Type": "application/json"
    }

    payload = {
        "endpointId": "predefined-openai-gpt4o",
        "query": f"{context}\n\nUSER QUESTION:\n{user_query}",
        "responseMode": "sync"
    }

    r = requests.post(url, json=payload, headers=headers)
    r.raise_for_status()

    return r.json()

@app.get("/atlas/chat/history/{request_id}")
def get_chat_history(request_id: str):
    if request_id not in CHAT_SESSIONS:
        return {"error": "Chat not started for this request_id"}

    session_id = CHAT_SESSIONS[request_id]

    url = f"https://api.on-demand.io/chat/v1/sessions/{session_id}/messages"
    headers = {
        "apikey": ONDEMAND_API_KEY,
        "Content-Type": "application/json"
    }

    r = requests.get(url, headers=headers)
    r.raise_for_status()

    return r.json()


''' For Frontend Testing 

Frontend logic:

On page load:

GET /atlas/chat/history/{request_id}


Render past messages

On new question:

POST /atlas/chat/query/{request_id}


Append response

Repeat
'''

''' Media API PDF'''

chat_sessions = load_chat_sessions()
chat_sessions_id = chat_sessions.get("demo-1", "")
if not chat_sessions_id:
    raise Exception("No chat session found for request_id")
def upload_pdf_to_media_api(pdf_path: str, chat_session_id: str):
    url = "https://api.on-demand.io/media/v1/public/file/raw"

    headers = {
        "apikey": ONDEMAND_API_KEY
    }

    with open(pdf_path, "rb") as f:
        files = {
            "file": ("ATLAS_Consulting_Report.pdf", f, "application/pdf")
        }

        data = {
            "name": "ATLAS Consulting Report",
            "plugins": "plugin-1713954536",   # ✅ NOT JSON
            "responseMode": "sync",
            "sessionId": chat_session_id,
            "createdBy": "ATLAS"
        }

        response = requests.post(
            url,
            headers=headers,
            files=files,
            data=data
        )

    print("MEDIA API STATUS:", response.status_code)
    print("MEDIA API RESPONSE:", response.text)

    response.raise_for_status()
    return response.json()

# @app.post("/atlas/report/generate/{request_id}")
# def generate_report(request_id: str):
#     if not SESSION:
#         return {"error": "No session data available"}

#     output_dir = "reports"
#     os.makedirs(output_dir, exist_ok=True)

#     pdf_path = f"{output_dir}/consulting_report_{request_id}.pdf"

#     generate_consulting_pdf(SESSION, pdf_path)

#     return FileResponse(
#         pdf_path,
#         media_type="application/pdf",
#         filename=f"consulting_report_{request_id}.pdf"
#     )


@app.post("/atlas/report/generate/{request_id}")
def generate_report(request_id: str):
    if not SESSION:
        return {"error": "No session data available"}

    # 1. Load chat session mapping
    chat_sessions = load_chat_sessions()  # from chat_session.json

    chat_session_id = chat_sessions.get(request_id)
    if not chat_session_id:
        return {"error": "No chat session found for request_id"}

    # 2. Generate PDF
    output_dir = "reports"
    os.makedirs(output_dir, exist_ok=True)

    pdf_path = f"{output_dir}/consulting_report_{request_id}.pdf"
    generate_consulting_pdf(SESSION, pdf_path)

    # 3. Upload PDF using REAL chat sessionId
    media_response = upload_pdf_to_media_api(
        pdf_path=pdf_path,
        chat_session_id=chat_session_id   # ✅ FIX
    )

    # 4. Persist media info
    SESSION["media"] = media_response
    save_session(SESSION)

    return {
        "status": "success",
        "pdf_generated": True,
        "media_uploaded": True,
        "media_id": media_response["data"]["id"],
        "extracted_text_url": media_response["data"].get("extractedTextUrl")
    }

@app.post("/atlas/report/{request_id}/ask")
def ask_report_question(request_id: str, payload: dict):
    question = payload.get("question")
    if not question:
        return {"error": "Question is required"}

    # Load chat session id
    chat_sessions = load_chat_sessions()  # your existing helper
    session_id = chat_sessions.get(request_id)

    if not session_id:
        return {"error": "Chat session not found for this request"}

    url = f"https://api.on-demand.io/chat/v1/sessions/{session_id}/query"
    headers = {
        "Content-Type": "application/json",
        "apikey": ONDEMAND_API_KEY
    }

    body = {
        "endpointId": "predefined-openai-gpt4o",
        "query": question,
        "responseMode": "sync"
    }

    r = requests.post(url, json=body, headers=headers)
    r.raise_for_status()

    return r.json()
